import time
import requests

class Session():
    ''' A QuestradeAPI session. It contains information that allows to send
    requests to the Questrade API.

    '''

    ACCESS_TOKEN_HOST = 'https://login.questrade.com'
    ACCESS_TOKEN_ENDPOINT = '/oauth2/token'

    def __init__(self, refresh_token):

        # Refresh token generated by the Questrade API
        self.refresh_token = refresh_token

        # Access token returned when the refresh token is redeemed
        self.access_token = None

        # Unix epoch time at which the access token is no longer valid
        self.access_valid_until = 0

        # The API server that can be querried using the current access token
        self.api_server = None

    def __enter__(self):
        return self

    def __exit__(self, *args):
        pass

    def get_access_data(self):
        '''Returns the data required to access the server, namely a access token 
        and the api server's address in a tuple.

        If the access token is expired, the refresh token is redeemed.

        '''
        now = time.time()
        if now > self.access_valid_until:
            token_data = self.redeem_refresh_token()
            self.refresh_token = token_data['refresh_token']
            self.access_token = token_data['access_token']
            self.access_valid_until = now + token_data['expires_in']
            self.api_server = token_data['api_server']
        return (self.access_token, self.api_server)

    def redeem_refresh_token(self):
        ''' Redeems the given refresh token to the questrade login server and 
        returnes the received data.

        '''
        params = {
            'grant_type': 'refresh_token',
            'refresh_token': self.refresh_token
        }
        r = requests.post(
            'https://login.questrade.com/oauth2/token',
            params=params
        )
        return r.json()

    def do_get(self, endpoint, params={}):
        ''' Performs a GET request to the Questrade API.

        Parameters
        ----------
        endpoint : :obj:`str`
            The webservice endpoint te request is sent to.
        params : :obj:`dict`, optional
            The parameters to include in the request.
            
        '''
        access_token, api_server = self.get_access_data()
        headers = {'Authorization': 'Bearer {}'.format(access_token)}
        r = requests.get(api_server + endpoint, headers=headers, params=params)
        return r.json()

    def do_post(self, endpoint, params={}):
        ''' Performs a POST request to the Questrade API.

        Parameters
        ----------
        endpoint : :obj:`str`
            The webservice endpoint te request is sent to.
        params : :obj:`dict`, optional
            The parameters to include in the request.
            
        '''
        access_token, api_server = self.get_access_data()
        headers = {'Authorization': 'Bearer {}'.format(access_token)}
        r = requests.post(api_server + endpoint, headers=headers, params=params)
        return r.json()

    def do_delete(self, endpoint, params={}):
        ''' Performs a DELETE request to the Questrade API.

        Parameters
        ----------
        endpoint : :obj:`str`
            The webservice endpoint te request is sent to.
        params : :obj:`dict`, optional
            The parameters to include in the request.

        '''
        access_token, api_server = self.get_access_data()
        headers = {'Authorization': 'Bearer {}'.format(access_token)}
        r = requests.delete(api_server + endpoint, headers=headers, params=params)
        return r.json()

    def get_time(self):
        '''Retrieve current server time.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        return self.do_get('v1/time')

    def get_accounts(self):
        '''Retrieves the accounts associated with the user on behalf of which 
        the API client is authorized.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        return self.do_get('v1/accounts')

    def get_positions(self, id):
        ''' Retrives positions in a specified account.

        Parameters
        ----------
        id : :obj:`str`
            Account number

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        return self.do_get('v1/accounts/{}/positions'.format(id))

    def get_balances(self, id):
        ''' Retrieves per-currency and combined balances for a specified account.

        Parameters
        ----------
        id : :obj:`str`
            Account number

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        return self.do_get('v1/accounts/{}/balances'.format(id))

    def get_executions(self, id, start_time=None, end_time=None):
        ''' Retrieves executions for a specific account.

        Parameters
        ----------
        id : :obj:`str`
            Account number
        start_time : :obj:`datetime`, optional 
            Start of the time range. Defaults to today 00:00am.
        end_time : :obj:`datetime`, optional
            End of the time range. Defaults to todat 11:59pm.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        params = {}
        if start_time:
            params.update({'startTime': utils.add_local_tz(start_time)})
        if end_time:
            params.update({'end_time': utils.add_local_tz(end_time)})
        return self.do_get('v1/accounts/{}/executions'.format(id), params)

    def get_orders(self, id, state_filter=None, start_time=None, end_time=None, 
        order_ids=None):
        ''' Retrieves orders for a specified account.

        Parameters
        ----------
        id : :obj:`str`
            Account number
        state_filter : :obj:`str`
            'All', 'Open' or 'Closed'. Retreive all, active or closed orders. 
            Defaults to 'All'.
        start_time : :obj:`datetime`, optional 
            Start of the time range. Defaults to today 00:00am.
        end_time : :obj:`datetime`, optional
            End of the time range. Defaults to todat 11:59pm.
        order_ids : int, optional
            Retrieve specific orders details.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        params={}
        if start_time:
            params.update({'startTime': utils.add_local_tz(start_time)})
        if end_time:
            params.update({'endTime': utils.add_local_tz(end_time)})
        if state_filter:
            params.update({'stateFilter': state_filter})
        if order_ids:
            params.update({'ids': ','.join(map(str, order_ids))})
        return self.do_get('v1/accounts/{}/orders'.format(id), params)

    def get_activities(self, id, start_time=None, end_time=None):
        ''' Retrieve account activities, including cash transactons, dividends,
        trades, etc.

        Parameters
        ----------
        id : :obj:`list` of :obj:`str`
            Account number.
        start_time : :obj:`datetime`, optional
            Start of the time range. Defaults to today 12:00am.
        end_time : :obj:`endtime`, optional
            End of the time range Defaults to today 11:59pm.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        params={}
        if start_time:
            params.update({'startTime': utils.add_local_tz(start_time)})
        if end_time:
            params.update({'endTime': utils.add_local_tz(end_time)})
        return self.do_get('v1/accoutns/{}/activities'.format(id), params)

    def get_symbols(names=None, ids=None, id=None):
        ''' Retrieves detailed information about one or more symbol.

        Parameters
        ----------
        name : :obj:`list` of :obj:`str`
            List of symbol names.
        ids : :obj:`list` of :obj:`int`
            List of symbol ids.
        id : :obj:`int`
            Internal symbol identifier. Mutually exclusive with 'ids' parameter.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        Either list of names or ids can be specified, but not both. If 'names' 
        is specified, it takes precedence over 'ids', which takes precedence 
        over 'id'.

        '''
        params={}
        endpoint = 'v1/symbols'
        if names:
            if isinstance(names, str):
                params.update({'names': names})
            else:
                params.update({'names': ','.join(names)})
        elif ids:
            params.update({'ids': ','.join(map(str, ids))})
        elif id:
            endpoint += '/' + str(id)
        return self.do_get(endpoint, params)

    def get_symbols_search(self, prefix, offset=None):
        ''' Retrieves symbol(s) using several search criteria.

        Parameters
        ----------
        prefix : :obj:`str`
            Prefix of a symbol or any word in the description.
        offset : :obj:`int`
            Offset in number of records from the beginning of a result set.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        params={'prefix': prefix}
        if offset:
            params.update({'offset': offset})
        return self.do_get('v1/symbols/search', params)

    def get_option_chain(self, id):
        '''Retrieves an option chain for a particular underlying symbol.

        Parameters
        ----------
        id : :obj:`int`
            Internal symbol identifier.

        '''
        return self.do_get('v1/symbols/{}/options'.format(id))

    def get_markets(self):
        '''Retrieves information about supported markets.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        return self.do_get('v1/markets')

    def get_quotes(self, id=None, ids=None):
        '''Retrieves a single Level 1 market data quote for one or more symbols.

        Parameters
        ----------
        id : :obj:`int`
            Internal symbol identifier (mutually exclusive with 'ids' argument).
        ids : :obj:`list` of :obj:`int`
            List of symbol ids.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        endpoint = 'v1/markets/quotes'
        if id:
            endpoint += '/' + str(id)
            return self.do_get(endpoint)
        else:
            params = {'ids': ','.join(map(str, ids))}
            return self.do_get(endpoint, params)

    def get_quotes_options(self, filters=None, ids=None):
        ''' Retrieves a single Level 1 market data quote and Greek data for one 
        or more option symbols.

        .. todo::
            Add link to description of OptionIdFilter and util to create it.

        Parameters
        ----------
        filters : :obj:`list` of :obj:`dict`
            List of OptionIdFilter structures.
        ids : :obj:`list` of :obj:`int`
            List of option IDs.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        OptionIdFilter structures:
        optionType (enum)       --  Option type
        underlyingId (int)      --  Underlying ID
        expiryDate (datetime)   --  Expiry date
        minstrikePrice (double) --  Min strike price
        maxstrikePrice (double) --  Max strike price

        '''
        params = {}
        params.update({'optionIds': ids})
        params.update({'filters': filters})
        return self.do_get('v1/markets/quotes/options', params)

    def get_quotes_strategies(self, variants):
        '''Retrieve a calculated L1 market data quote for a single or many 
        multi-leg strategies.
        
        .. todo::
            Add link to description of StrategyVariantRequest and StrategyLeg
            and utils to create them.

        Parameters
        ----------
        variants : :obj:`list` of :obj:`dict`
            Array of Strategy Variants.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        StrategyVariantRequest:
        variantId (int) --  Variant ID
        strategy (enum) --  Strategy type 
        legs (dic list) --  Array of Strategy legs

        StrategyLeg:
        symbolId (int)  --  Internal symbol identifier
        action (enum)   --  Order side
        ratio (int)     --  Numeric ration of the leg strategy

        '''
        params = {'variants': variants}
        return self.do_get('v1/markets/quotes/strategies', params)

    def get_candles(self, id, start_time, end_time, interval):
        ''' Retrieves historical market data in the form of OHLC candlesticks for a 
        specified symbol. This call is limited to returning 2,000 candlesticks in
        a single response.

        .. todo::
            Add link to interval allowed values.

        Parameters
        ----------
        id : :obj:`int`
            Internal symbol indentifier.
        startTime : :obj:`datetime`
            Beginning of the candlestick range.
        endTime : :obj:`datetime`
            End of the candlestick range.
        interval : :obj:`str`
            Interval of a single candlestick. Allowed values: 

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        params = {
            'startTime': utils.add_local_tz(start_time),
            'endTime': utils.add_local_tz(end_time), 
            'interval': interval
        }
        return do_get('v1/markets/candles/{}'.format(id), params)

    def post_order(self, account_id, symbol_id, quantity, iceberg_quantity, 
        limit_price, stop_price, all_or_none, anonymous, order_type, 
        time_in_force, action, primary_route, secondary_route, order_id=None, 
        impact=False):
        ''' Allows to place/replace or estimate the impact of an order against a 
        certain account.
        
        .. todo::
            Link to allowed values for order_type, time_in_force, action,
            primary_route and secondary_route.
            
        Parameters
        ----------
        id : :obj:`str`
            Account number against which the order is submited.
        order_id : :obj:`int`
            Order id of the order to be replaced.
        symbol_id : :obj:`int`
            Internal symbol identifier.
        quantity : :obj:`int`
            Order quantity.
        iceberg_quantity : :obj:`int`
            Iceberg instruction quantity.
        limit_price : :obj:`double`
            Limit price.
        stop_price : :obj:`double`
            Stop price.
        all_or_none : :obj:`bool`
            Whether all are none is enabled.
        anonymous : :obj:`bool`
            Wheter anonymous is enabled.
        order_type : :obj:`str`
            Order type.
        time_in_force : :obj:`str`
            Time-In-Force.
        action : :obj:`str`
            Order side.
        primary_route : :obj:`str`
            Primary route order.
        secondary_route : :obj:`str`
            Secondary order route.
        impact : :obj:`bool`
            Calculate impact instead of placing order.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        endpoint = 'v1/accounts/{}/orders'.format(account_id)
        if order_id:
            endpoint += '/' + str(order_id)
        if impact:
            endpoint += '/impact'
        params = {
            'symbolId': symbol_id,
            'quantity': quantity,
            'icebergQuantity': iceberg_quantity,
            'limitPrice': limit_price,
            'stopPrice': stop_price,
            'isAllOrNone': all_or_none,
            'isAnonymous': anonymous,
            'orderType': order_type,
            'timeInForce': time_in_force,
            'action': action,
            'primaryRoute': primary_route,
            'secondary_route': secondary_route
        }
        return self.do_post(endpoint, params)

    def delete_order(account_id, order_id):
        ''' Allows to cancel an existing order.

        Arguments
        ---------
        account_id : :obj:`str`
            Account number.
        order_id : :obj:`int`
            Internal identifier of the order.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        endpoint = 'v1/accounts/{}/order/{}'.format(account_id, order_id)
        return self.do_delete(endpoint)

    def post_bracket_order(self, account_id, symbol_id, primary_route, 
        secondary_route, components, impact=False):
        ''' Allows to place/replace or estimate the impact of a bracket order
        against a certain account.

        .. todo::
            Link to link to BracketOrderComponent structure and util to create 
            it.

        Parameters
        ----------
        account_id : :obj:`str`
            Account number.
        symbol_id : :obj:`int`
            Internal symbol identifier.
        primary_route : :obj:`str`
            Primary order route.
        secondary_route : :obj:`str`
            Secondary order route.
        components : :obj:`list` of :obj:`dict`
            List of Bracket Order Components.
        impact : :obj:`bool`
            Calculate impact instead of placing order.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        Bracket Order Components:
        orderId (int)       --  Order ID of active order, or 0 for new order
        quantity (double)   --  Order quantity
        action (enum)       --  Order side
        limitPrice (double) --  Limit price
        stopPrice (double)  --  Stop price
        orderType (enum)    --  Order type
        timeInForce (enum)  --  Order duration
        orderClass (enum)   --  Type of component

        '''
        endpoint = 'v1/accounts/{}/orders/bracket'.format(account_id)
        if impact:
            endpoint += '/impact'
        params={
            'symbolId': symbol_id,
            'primaryRoute': primary_route,
            'secondaryRoute': secondary_route,
            'components': components
        }
        return self.do_post('v1/accounts/{}/orders/bracket', params)

    def post_multi_leg_strategy_order(self, account_id, symbol_id, limit_price, 
        order_type, time_in_force, primary_route, secondary_route, legs, 
        strategy, impact=False):
        ''' Allows to place/replace or estimate the impact of a multi-leg strategy 
        against a certain account.

        .. todo::
            Link to InsertOrderLegData structure and util to create it.

        .. todo::
            Link to allowed values for orderType, time_in_force, primary_route,
            scondary_route and strategy enums.
        
        Parameters
        ----------
        account_id : :obj:`str`
            Account number.
        symbol_id : :obj:`int`
            Internal symbol identifier.
        limitPrice : :obj:`double`
            Limit price.
        orderType : :obj:`str`
            Order type.
        time_in_force : :obj:`str`
            Order duration.
        primary_route : :obj:`str`
            Primary order route.
        secondary_route : :obj:`str`
            Secondary order route.
        legs : :obj:`list` of :obj:`dict`
            Array of InsertOrderLegData structures.
        strategy : :obj:`str`
            Strategy type.
        impact : :obj:`bool`
            Calculate impact instead of placing order.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.
        
        InsertOrderLegData:
        symbolId (int)      --  Internal symbol identifier
        action (enum)       --  Leg action
        legQuantity (int)   --  Leg quantity

        '''
        endpoint = '/v1/accounts/{}/orders/strategy'.format(account_id)
        if impact:
            endpoint += '/impact'
        params = {
            'symbolId': symbol_id,
            'limitPrice': limit_price,
            'orderType': order_type,
            'timeInForce': time_in_force,
            'primaryRoute': primary_route,
            'secondaryRoute': secondary_route,
            'legs': legs,
            'strategy': strategy
        }
        return self.do_post(endpoint, params)