import time
import requests

class Session():
    ''' A QuestradeAPI session that allows the user to perform API calls.

    Attributes
    ----------
    refresh_token : :obj:`str`
        Refresh token generated by the Questrade API.
    access_token : :obj:`str`
        Access token returned when the refresh token is redeemed.
    access_valid_until : :obj:`long`
        Unix time at which the access token is no longer valid.
    api_server : :obj:`str`
        The API server that can be querried using the current access token.

    '''

    ACCESS_TOKEN_HOST = 'https://login.questrade.com'
    ACCESS_TOKEN_ENDPOINT = '/oauth2/token'

    def __init__(self, refresh_token):
        '''Constructor.

        Parameters
        ----------
        refresh_token : :obj:`str`
            Initial refresh token used to get an access token.

        '''
        self.refresh_token = refresh_token
        self.access_token = None
        self.access_valid_until = 0
        self.api_server = None

    def _get_access_data(self):
        '''Method used to get the data required to acces the API server.

        Returns
        -------
        :obj:`str`
            Valid access token.
        :obj:`str`
            API server associated with the returned access token.

        '''
        now = time.time()
        if now > self.access_valid_until:
            token_data = self.redeem_refresh_token()
            self.refresh_token = token_data['refresh_token']
            self.access_token = token_data['access_token']
            self.access_valid_until = now + token_data['expires_in']
            self.api_server = token_data['api_server']
        return (self.access_token, self.api_server)

    def redeem_refresh_token(self):
        ''' Redeems the given refresh token to the questrade login server.

        Returns
        -------
        :obj:`dict`
            Data returned by the server following the redeem request.

        '''
        params = {
            'grant_type': 'refresh_token',
            'refresh_token': self.refresh_token
        }
        r = requests.post(
            'https://login.questrade.com/oauth2/token',
            params=params
        )
        return r.json()

    def do_get(self, endpoint, params={}):
        ''' Performs a GET request to the Questrade API.

        Parameters
        ----------
        endpoint : :obj:`str`
            The webservice endpoint te request is sent to.
        params : :obj:`dict`, optional
            The parameters to include in the request.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.
            
        '''
        access_token, api_server = self._get_access_data()
        headers = {'Authorization': 'Bearer {}'.format(access_token)}
        r = requests.get(api_server + endpoint, headers=headers, params=params)
        return r.json()

    def do_post(self, endpoint, params={}):
        ''' Performs a POST request to the Questrade API.

        Parameters
        ----------
        endpoint : :obj:`str`
            The webservice endpoint te request is sent to.
        params : :obj:`dict`, optional
            The parameters to include in the request.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.
            
        '''
        access_token, api_server = self._get_access_data()
        headers = {'Authorization': 'Bearer {}'.format(access_token)}
        r = requests.post(api_server + endpoint, headers=headers, params=params)
        return r.json()

    def do_delete(self, endpoint, params={}):
        ''' Performs a DELETE request to the Questrade API.

        Parameters
        ----------
        endpoint : :obj:`str`
            The webservice endpoint te request is sent to.
        params : :obj:`dict`, optional
            The parameters to include in the request.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        access_token, api_server = self._get_access_data()
        headers = {'Authorization': 'Bearer {}'.format(access_token)}
        r = requests.delete(api_server + endpoint, headers=headers, params=params)
        return r.json()

    def get_time(self):
        '''Retrieve current server time.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        return self.do_get('v1/time')

    def get_accounts(self):
        '''Retrieves the accounts associated with the user on behalf of which 
        the API client is authorized.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        return self.do_get('v1/accounts')

    def get_positions(self, id):
        ''' Retrives positions in a specified account.

        Parameters
        ----------
        id : :obj:`str`
            Account number

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        return self.do_get('v1/accounts/{}/positions'.format(id))

    def get_balances(self, id):
        ''' Retrieves per-currency and combined balances for a specified account.

        Parameters
        ----------
        id : :obj:`str`
            Account number

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        return self.do_get('v1/accounts/{}/balances'.format(id))

    def get_executions(self, id, start_time=None, end_time=None):
        ''' Retrieves executions for a specific account.

        Parameters
        ----------
        id : :obj:`str`
            Account number
        start_time : :obj:`datetime`, optional 
            Start of the time range. Defaults to today 00:00am.
        end_time : :obj:`datetime`, optional
            End of the time range. Defaults to todat 11:59pm.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        params = {}
        if start_time:
            params.update({'startTime': utils.add_local_tz(start_time)})
        if end_time:
            params.update({'end_time': utils.add_local_tz(end_time)})
        return self.do_get('v1/accounts/{}/executions'.format(id), params)

    def get_orders(self, id, state_filter=None, start_time=None, end_time=None, 
        order_ids=None):
        ''' Retrieves orders for a specified account.

        Parameters
        ----------
        id : :obj:`str`
            Account number
        state_filter : :obj:`str`, {'All', 'Open', 'Close'}
            Retreive all, active or closed orders.
        start_time : :obj:`datetime`, optional 
            Start of the time range. Defaults to today 00:00am.
        end_time : :obj:`datetime`, optional
            End of the time range. Defaults to todat 11:59pm.
        order_ids : int, optional
            Retrieve specific orders details.

        Note
        ----
        More details on allowed `state_filter` values can be found `here 
        <https://www.questrade.com/api/documentation/rest-operations/enumerat \
        ions/enumerations#order-state-filter-type>`__.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        params={}
        if start_time:
            params.update({'startTime': utils.add_local_tz(start_time)})
        if end_time:
            params.update({'endTime': utils.add_local_tz(end_time)})
        if state_filter:
            params.update({'stateFilter': state_filter})
        if order_ids:
            params.update({'ids': ','.join(map(str, order_ids))})
        return self.do_get('v1/accounts/{}/orders'.format(id), params)

    def get_activities(self, id, start_time=None, end_time=None):
        ''' Retrieve account activities, including cash transactons, dividends,
        trades, etc.

        Parameters
        ----------
        id : :obj:`list` of :obj:`str`
            Account number.
        start_time : :obj:`datetime`, optional
            Start of the time range. Defaults to today 12:00am.
        end_time : :obj:`endtime`, optional
            End of the time range Defaults to today 11:59pm.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        params={}
        if start_time:
            params.update({'startTime': utils.add_local_tz(start_time)})
        if end_time:
            params.update({'endTime': utils.add_local_tz(end_time)})
        return self.do_get('v1/accoutns/{}/activities'.format(id), params)

    def get_symbols(names=None, ids=None, id=None):
        ''' Retrieves detailed information about one or more symbol.

        Parameters
        ----------
        name : :obj:`list` of :obj:`str`
            List of symbol names.
        ids : :obj:`list` of :obj:`int`
            List of symbol ids.
        id : :obj:`int`
            Internal symbol identifier. Mutually exclusive with 'ids' parameter.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        Either list of names or ids can be specified, but not both. If 'names' 
        is specified, it takes precedence over 'ids', which takes precedence 
        over 'id'.

        '''
        params={}
        endpoint = 'v1/symbols'
        if names:
            if isinstance(names, str):
                params.update({'names': names})
            else:
                params.update({'names': ','.join(names)})
        elif ids:
            params.update({'ids': ','.join(map(str, ids))})
        elif id:
            endpoint += '/' + str(id)
        return self.do_get(endpoint, params)

    def get_symbols_search(self, prefix, offset=None):
        ''' Retrieves symbol(s) using several search criteria.

        Parameters
        ----------
        prefix : :obj:`str`
            Prefix of a symbol or any word in the description.
        offset : :obj:`int`
            Offset in number of records from the beginning of a result set.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        params={'prefix': prefix}
        if offset:
            params.update({'offset': offset})
        return self.do_get('v1/symbols/search', params)

    def get_option_chain(self, id):
        '''Retrieves an option chain for a particular underlying symbol.

        Parameters
        ----------
        id : :obj:`int`
            Internal symbol identifier.

        '''
        return self.do_get('v1/symbols/{}/options'.format(id))

    def get_markets(self):
        '''Retrieves information about supported markets.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        return self.do_get('v1/markets')

    def get_quotes(self, id=None, ids=None):
        '''Retrieves a single Level 1 market data quote for one or more symbols.

        Parameters
        ----------
        id : :obj:`int`
            Internal symbol identifier (mutually exclusive with 'ids' argument).
        ids : :obj:`list` of :obj:`int`
            List of symbol ids.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        endpoint = 'v1/markets/quotes'
        if id:
            endpoint += '/' + str(id)
            return self.do_get(endpoint)
        else:
            params = {'ids': ','.join(map(str, ids))}
            return self.do_get(endpoint, params)

    def get_quotes_options(self, filters=None, ids=None):
        ''' Retrieves a single Level 1 market data quote and Greek data for one 
        or more option symbols.

        Parameters
        ----------
        filters : :obj:`list` of :obj:`dict`
            List of OptionIdFilter structures. See the utility function
            :func:`questradeapi.utils.create_option_id_filter`.
        ids : :obj:`list` of :obj:`int`
            List of option IDs.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        params = {}
        params.update({'optionIds': ids})
        params.update({'filters': filters})
        return self.do_get('v1/markets/quotes/options', params)

    def get_quotes_strategies(self, variants):
        '''Retrieve a calculated L1 market data quote for a single or many 
        multi-leg strategies.

        Parameters
        ----------
        variants : :obj:`list` of :obj:`dict`
            List of StrategyVariantsRequest structures. See utility function 
            :func:`questradeapi.utils.create_strategy_variant_request`.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        params = {'variants': variants}
        return self.do_get('v1/markets/quotes/strategies', params)

    def get_candles(self, id, start_time, end_time, interval):
        ''' Retrieves historical market data in the form of OHLC candlesticks for a 
        specified symbol. This call is limited to returning 2,000 candlesticks in
        a single response.

        Parameters
        ----------
        id : :obj:`int`
            Internal symbol indentifier.
        startTime : :obj:`datetime`
            Beginning of the candlestick range.
        endTime : :obj:`datetime`
            End of the candlestick range.
        interval : :obj:`str`, {'OneMinute', 'TwoMinutes', 'ThreeMinutes', \
        'FourMinutes', 'FiveMinutes', 'TenMinutes', 'FifteenMinutes', \
        'TwentyMinutes', 'HalfHour', 'OneHour', 'TwoHours', 'FourHours', \
        'OneDay', 'OneWeek', 'OneMonth', 'OneYear'}
            Interval of a single candlestick.
        
        Note
        ----
        More details on allowed `interval` values can be found `here 
        <https://www.questrade.com/api/documentation/rest-operations/ \
        enumerations/enumerations#historical-data-granularity>`__

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        params = {
            'startTime': utils.add_local_tz(start_time),
            'endTime': utils.add_local_tz(end_time), 
            'interval': interval
        }
        return do_get('v1/markets/candles/{}'.format(id), params)

    def post_order(self, account_id, symbol_id, quantity, iceberg_quantity, 
        limit_price, stop_price, all_or_none, anonymous, order_type, 
        time_in_force, action, primary_route, secondary_route, order_id=None, 
        impact=False):
        ''' Allows to place/replace or estimate the impact of an order against a 
        certain account.
            
        Parameters
        ----------
        id : :obj:`str`
            Account number against which the order is submited.
        order_id : :obj:`int`
            Order id of the order to be replaced.
        symbol_id : :obj:`int`
            Internal symbol identifier.
        quantity : :obj:`int`
            Order quantity.
        iceberg_quantity : :obj:`int`
            Iceberg instruction quantity.
        limit_price : :obj:`double`
            Limit price.
        stop_price : :obj:`double`
            Stop price.
        all_or_none : :obj:`bool`
            Whether all are none is enabled.
        anonymous : :obj:`bool`
            Wheter anonymous is enabled.
        order_type : :obj:`str`, 'Market', 'Limit', 'Stop', 'StopLimit', \
        'TrailStopInPercentage', 'TrailStopInDollar', \
        'TrailStopLimitInPercentage', 'TrailStopLimitInDollar', 'LimitOnOpen', \
        'LimitOnClose'}
            Order type.
        time_in_force : :obj:`str`, {'Day', 'GoodTillCanceled', \
        'GoodTillExtendedDay', 'GoodTillDate', 'ImmediateOrCancel', FillOrKill}
            Order duration.
        action : :obj:`str`, {'Buy', 'Sell'}
            Order side.
        primary_route : :obj:`str`, optional
            Primary order route. Defaults to 'AUTO'.
        secondary_route : :obj:`str`, optional
            Secondary order route. Defaults to 'AUTO'.
        impact : :obj:`bool`
            Calculate impact instead of placing order.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        endpoint = 'v1/accounts/{}/orders'.format(account_id)
        if order_id:
            endpoint += '/' + str(order_id)
        if impact:
            endpoint += '/impact'
        params = {
            'symbolId': symbol_id,
            'quantity': quantity,
            'icebergQuantity': iceberg_quantity,
            'limitPrice': limit_price,
            'stopPrice': stop_price,
            'isAllOrNone': all_or_none,
            'isAnonymous': anonymous,
            'orderType': order_type,
            'timeInForce': time_in_force,
            'action': action,
            'primaryRoute': primary_route,
            'secondary_route': secondary_route
        }
        return self.do_post(endpoint, params)

    def delete_order(account_id, order_id):
        ''' Allows to cancel an existing order.

        Arguments
        ---------
        account_id : :obj:`str`
            Account number.
        order_id : :obj:`int`
            Internal identifier of the order.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        endpoint = 'v1/accounts/{}/order/{}'.format(account_id, order_id)
        return self.do_delete(endpoint)

    def post_bracket_order(self, account_id, symbol_id, primary_route, 
        secondary_route, components, impact=False):
        ''' Allows to place/replace or estimate the impact of a bracket order
        against a certain account.

        Parameters
        ----------
        account_id : :obj:`str`
            Account number.
        symbol_id : :obj:`int`
            Internal symbol identifier.
        primary_route : :obj:`str`, optional
            Primary order route. Defaults to 'AUTO'.
        secondary_route : :obj:`str`, optional
            Secondary order route. Defaults to 'AUTO'.
        components : :obj:`list` of :obj:`dict`
            List of Bracket Order Components. See the utility function
            :func:`questradeapi.utils.create_bracket_order_component`.
        impact : :obj:`bool`
            Calculate impact instead of placing order.

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        endpoint = 'v1/accounts/{}/orders/bracket'.format(account_id)
        if impact:
            endpoint += '/impact'
        params={
            'symbolId': symbol_id,
            'primaryRoute': primary_route,
            'secondaryRoute': secondary_route,
            'components': components
        }
        return self.do_post('v1/accounts/{}/orders/bracket', params)

    def post_multi_leg_strategy_order(self, account_id, symbol_id, limit_price, 
        order_type, time_in_force, primary_route, secondary_route, legs, 
        strategy, impact=False):
        ''' Allows to place/replace or estimate the impact of a multi-leg 
        strategy against a certain account.
        
        Parameters
        ----------
        account_id : :obj:`str`
            Account number.
        symbol_id : :obj:`int`
            Internal symbol identifier.
        limit_price : :obj:`double`
            Limit price.
        order_type : :obj:`str`, 'Market', 'Limit', 'Stop', 'StopLimit', \
        'TrailStopInPercentage', 'TrailStopInDollar', \
        'TrailStopLimitInPercentage', 'TrailStopLimitInDollar', 'LimitOnOpen', \
        'LimitOnClose'}
            Order type.
        time_in_force : :obj:`str`, {'Day', 'GoodTillCanceled', \
        'GoodTillExtendedDay', 'GoodTillDate', 'ImmediateOrCancel', FillOrKill}
            Order duration.
        primary_route : :obj:`str`, optional
            Primary order route. Defaults to 'AUTO'.
        secondary_route : :obj:`str`, optional
            Secondary order route. Defaults to 'AUTO'.
        legs : :obj:`list` of :obj:`dict`
            List of InsertOrderLegData structures. See the utility function
            :func:`questradeapi.utils.create_insert_order_leg_data`.
        strategy : :obj:`str`, {'CoveredCall', 'MarriedPuts', \
        'VerticalCallSpread', 'VerticalPutSpread', 'CalendarCallSpread', \
        'CalendarPutSpread', 'DiagonalCallSpread', 'DiagonalPutSpread', \
        'Collar', 'Straddle', 'Strangle', 'ButterflyCall', 'ButterflyPut', \
        'IronButterfly', 'CondorCall', 'Custom'}
            Strategy type.
        impact : :obj:`bool`
            Calculate impact instead of placing order.

        Note
        ----
        More details on allowed `order_type` values can be found `here 
        <https://www.questrade.com/api/documentation/rest-operations/ \
        enumerations/enumerations#order-type>`__
        
        Note
        ----
        More details on allowed `time_in_force` values can be found `here 
        <https://www.questrade.com/api/documentation/rest-operations/ \
        enumerations/enumerations#order-time-in-force>`__

        Note
        ----
        More details on allowed `strategy` values can be found `here 
        <http://www.questrade.com/api/documentation/rest-operations/ \
        enumerations/enumerations#strategy-types>`__

        Returns
        -------
        :obj:`dict`
            Dictionary containing the response properties.

        '''
        endpoint = '/v1/accounts/{}/orders/strategy'.format(account_id)
        if impact:
            endpoint += '/impact'
        params = {
            'symbolId': symbol_id,
            'limitPrice': limit_price,
            'orderType': order_type,
            'timeInForce': time_in_force,
            'primaryRoute': primary_route,
            'secondaryRoute': secondary_route,
            'legs': legs,
            'strategy': strategy
        }
        return self.do_post(endpoint, params)